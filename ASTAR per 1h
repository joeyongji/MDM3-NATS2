# —— 物理距离（km）
EARTH_RADIUS_KM = 6371.0
def haversine_km(lon1, lat1, lon2, lat2):
    rlat1 = math.radians(lat1); rlat2 = math.radians(lat2)
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = math.sin(dlat/2)**2 + math.cos(rlat1)*math.cos(rlat2)*math.sin(dlon/2)**2
    return 2 * EARTH_RADIUS_KM * math.asin(math.sqrt(a))

def phys_km_between(a, b):
    lon1, lat1 = idx_to_phys_x(a[0]), idx_to_phys_y(a[1])
    lon2, lat2 = idx_to_phys_x(b[0]), idx_to_phys_y(b[1])
    return haversine_km(lon1, lat1, lon2, lat2)

# —— 取“朝向最终目标的 900km 子目标”（若剩余不足900则直接终点）
def choose_window_goal(current, final_goal, window_km, mask, max_snap=4):
    total_km = phys_km_between(current, final_goal)
    if total_km <= window_km:
        return final_goal
    t = window_km / total_km
    xf = current[0] + t * (final_goal[0] - current[0])
    yf = current[1] + t * (final_goal[1] - current[1])
    zf = current[2] + t * (final_goal[2] - current[2])
    # 就近贴回可通行网格
    xi, yi, zi = int(round(xf)), int(round(yf)), int(round(zf))
    for r in range(max_snap+1):
        for dx in range(-r, r+1):
            for dy in range(-r, r+1):
                for dz in range(-r, r+1):
                    nx, ny, nz = xi+dx, yi+dy, zi+dz
                    if in_bounds(nx, ny, nz) and passable(nx, ny, nz, mask):
                        return (nx, ny, nz)
    return final_goal

# —— 计算从 u->v 这一步的“模型时间”（与 A* 保持一致的近似）
def step_time_units(u_node, v_node):
    ux, uy, uz = u_node
    vx, vy, vz = v_node
    dx, dy, dz = vx-ux, vy-uy, vz-uz
    dist = math.sqrt(dx*dx + dy*dy + dz*dz)  # 索引距离
    if dist == 0:
        return 0.0
    # 与 A* 相同：在起点取风并投影到水平航向
    u_wind, v_wind = get_wind_uv(ux, uy, uz)
    ex, ey = dx/dist, dy/dist
    Vg = TAS + (u_wind*ex + v_wind*ey)
    Vg = max(1e-3, Vg)
    Vg = max(0.05, Vg)
    return dist / Vg

# —— 按“飞行固定时长”沿路径前进，返回：到达节点索引 & 已用时（模型单位）
def advance_along_path_by_time(path, time_budget_units):
    """
    输入:
      path: 节点序列
      time_budget_units: 这次可用的模型时间预算
    输出:
      step_idx: 在 path 上停下来的节点索引（不跨越会超时的下一条边）
      used:     实际消耗的模型时间
      reached_end: 是否走到了 path 终点（即到达本段子目标）
    """
    if not path or len(path) < 2 or time_budget_units <= 0:
        return 0, 0.0, len(path) <= 1

    used = 0.0
    for i in range(len(path) - 1):
        dt = step_time_units(path[i], path[i + 1])
        # 下一条边会超时 -> 不跨越，停在当前节点 i
        if used + dt > time_budget_units:
            return i, used, False
        used += dt

    # 全部边都走完 -> 到达子目标
    return len(path) - 1, used, True


# —— 主循环：窗口=900km；每飞 1 小时重规划
WINDOW_KM = 900.0


# 例如：如果你希望“模型 1 个时间单位 = 0.25 小时（15分钟）”，则 TIME_UNIT_HOURS = 0.25
TIME_UNIT_HOURS = 1.0
ONE_HOUR_IN_TIME_UNITS = 1.0 / TIME_UNIT_HOURS  # 1 小时等于多少“模型时间单位”

def rolling_plan_by_hour(start, final_goal, mask, max_hours=1000, verbose=True):
    """
    每个外层循环代表“消耗最多 1 小时”。这一小时内可多次：
      选 900km 子目标 -> A* -> 在剩余时间内推进 -> 若提前到子目标继续下一段
    """
    curr = start
    traj = [curr]
    hours_acc = 0.0
    hour_idx = 0
    EPS = 1e-9

    while curr != final_goal and hour_idx < max_hours:
        hour_idx += 1
        remaining = ONE_HOUR_IN_TIME_UNITS
        inner_calls = 0

        while remaining > EPS and curr != final_goal:
            inner_calls += 1

            # 选择 900km 子目标（或不足 900km 时直接用最终目标）
            subgoal = choose_window_goal(curr, final_goal, WINDOW_KM, mask)
            path, cost, dist, _ = astar_3d(curr, subgoal, mask)
            if not path:
                print(f"[终止] 无法从 {curr} 规划至 {subgoal}。")
                return traj, hours_acc

            step_idx, used, reached_subgoal = advance_along_path_by_time(path, remaining)

            # 沿当前段推进（不重复起点）
            if step_idx >= 1:
                traj.extend(path[1:step_idx + 1])
                curr = path[step_idx]

            remaining -= used

            if verbose:
                print(f"  ├─ 段内第 {inner_calls} 次：耗时 {used:.3f} tu，"
                      f"到达 {curr}，距终点 {phys_km_between(curr, final_goal):.1f} km，"
                      f"小时剩余 {remaining:.3f} tu")

            # 防死循环：如果一条边都走不了（dt > 剩余预算且严格不超时），提早结束本小时
            if used <= EPS and not reached_subgoal:
                if verbose:
                    print("  └─ 剩余预算不足以通过下一条边，提前结束当前小时。")
                break

        hours_acc += 1.0
        if verbose:
            print(f"[{hour_idx:02d}] 本小时结束：位置 {curr}，距终点 ~{phys_km_between(curr, final_goal):.1f} km")

    if curr == final_goal:
        print("[完成] 抵达终点。")

    return traj, hours_acc


# —— 运行滚动规划（以“有禁飞”的图为例）
rolling_traj, hours_flown = rolling_plan_by_hour(start_point, goal_point, blocked)

# —— 可视化滚动轨迹（追加一条线）
if rolling_traj and len(rolling_traj) > 1:
    ax.plot([idx_to_phys_x(x) for x,y,z in rolling_traj],
            [idx_to_phys_y(y) for x,y,z in rolling_traj],
            [idx_to_phys_z(z) for x,y,z in rolling_traj],
            linewidth=2, alpha=0.9, label="Rolling 900km / 1h replanning")
    ax.legend(loc='upper left')
    plt.tight_layout()
    plt.show()
